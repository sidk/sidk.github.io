<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>4 ways to filter has_many associations</title>
    <link rel="stylesheet" href="/assets/css/style.css">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      <nav>
        <a href="/">List of All Articles</a>
      </nav>
      <h1>4 ways to filter has_many associations</h1>
      <section>
        <p>You have a model that <code class="language-plaintext highlighter-rouge">has_many</code> associations, and you’d like to get a collection of these models with their associations that satisfies a list of conditions both on the model and the association records. You’ve tried a few things, but whatever you’ve tried only “sort of” works (meaning, not really) and leaves you feeling like you need a push in the right direction.</p>

<p>Filtering <code class="language-plaintext highlighter-rouge">has_many</code> associations can be one of those problems which makes you scratch your head and want to do some extra reading to brush up on your <code class="language-plaintext highlighter-rouge">SQL</code> and <code class="language-plaintext highlighter-rouge">ActiveRecord</code> knowledge.</p>

<p>For example, let’s say you have <code class="language-plaintext highlighter-rouge">User</code> and <code class="language-plaintext highlighter-rouge">Project</code> models in your system, and you want to write a query that retrieves a collection of <code class="language-plaintext highlighter-rouge">users</code> with <code class="language-plaintext highlighter-rouge">projects</code> that were created in a given date range.</p>

<p>Depending on what you want your query to return, here are 4 different ways to approach this problem:</p>

<ol>
  <li>
    <p>The simplest thing you can do is to combine the <code class="language-plaintext highlighter-rouge">joins</code> and <code class="language-plaintext highlighter-rouge">where</code> methods that <code class="language-plaintext highlighter-rouge">ActiveRecord</code> gives you, like so:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   User.joins(:projects).where(projects: { zipcode: 30332 })
</code></pre></div>    </div>
    <p>This technique is a good choice when you need to filter your records by one or more attributes. This will give you back a collection of <code class="language-plaintext highlighter-rouge">User</code> records which all have projects with a zipcode of 30332.
 One gotcha to keep in mind is that since you’re doing a <code class="language-plaintext highlighter-rouge">INNER JOIN</code> with the <code class="language-plaintext highlighter-rouge">joins</code> method, <strong>this can return duplicates</strong>. Read on to point 2 to see how you can get around this.</p>
  </li>
  <li>More often than not, you might have scopes defined on your association models which you want to re-use. So when you want to use these scopes to do your filtering, get acquainted with <code class="language-plaintext highlighter-rouge">ActiveRecord's</code> <code class="language-plaintext highlighter-rouge">merge</code> function. According to the <a href="http://apidock.com/rails/ActiveRecord/SpawnMethods/merge"><code class="language-plaintext highlighter-rouge">ActiveRecord</code> documentation</a>, <code class="language-plaintext highlighter-rouge">merge</code> returns an array representing the intersection of the <code class="language-plaintext highlighter-rouge">ActiveRecord::Relation</code> that you call <code class="language-plaintext highlighter-rouge">merge</code> on, and the <code class="language-plaintext highlighter-rouge">ActiveRecord::Relation</code> that you pass in.<br />
 So, for example, if you have a scope in your <code class="language-plaintext highlighter-rouge">Project</code> model called <code class="language-plaintext highlighter-rouge">opened_recently</code>, which returns all <code class="language-plaintext highlighter-rouge">projects</code> which have been created within the last 10 days, you can do something like:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  User.joins(:projects).merge(Project.opened_recently)
</code></pre></div>    </div>
    <p>This will return to you a list of <code class="language-plaintext highlighter-rouge">User</code> objects which all satisfy the condition of having projects which were opened recently.
 Like I said before, one thing to keep in mind when you’re using <code class="language-plaintext highlighter-rouge">joins</code> for a <code class="language-plaintext highlighter-rouge">has_many</code> association is that since you are doing an <code class="language-plaintext highlighter-rouge">INNER JOIN</code>, <strong>it is possible that you will get back duplicate <code class="language-plaintext highlighter-rouge">User</code> (in our example) objects</strong> – basically one object for every ‘match’. 
 It’s easy enough to get around this with a call to the <code class="language-plaintext highlighter-rouge">uniq</code> method.</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> User.joins(:projects).merge(Project.opened_recently).uniq
</code></pre></div>    </div>
    <p>The <code class="language-plaintext highlighter-rouge">uniq</code> method works by changing your query from something like <code class="language-plaintext highlighter-rouge">SELECT `users` from ...</code> to something like <code class="language-plaintext highlighter-rouge">SELECT DISTINCT `users` from...</code></p>
  </li>
  <li>
    <p>If you’re going to be needing to retrieve information from the records you filter, especially information stored in the associations of these records, another option to consider is <a href="http://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations">eager loading and the <code class="language-plaintext highlighter-rouge">includes</code> method</a>. As you probably know, the benefit of eager loading is that you get to avoid the N + 1 queries problem.
 It’s pretty straightforward to filter by attributes or scopes on the association:
User.includes(:projects).where(projects: { zipcode: ‘30332’ })
 This will give us all <code class="language-plaintext highlighter-rouge">users</code> who have projects in Atlanta, and also eager load their projects.
 If in your <code class="language-plaintext highlighter-rouge">.where</code> you want you use an SQL fragment, then you need to call the <a href="http://apidock.com/rails/ActiveRecord/QueryMethods/references"><code class="language-plaintext highlighter-rouge">references</code></a> method:
User.includes(:projects).where(‘projects.deleted_at IS NOT NULL’).references(:projects)
 You can also use the <code class="language-plaintext highlighter-rouge">merge</code> method in conjunction with <code class="language-plaintext highlighter-rouge">includes</code> and <code class="language-plaintext highlighter-rouge">references</code> to make use of any scopes you might have defined in your association models, like so:
User.includes(:projects).merge(Project.opened_recently).references(:projects)
 You won’t need to use <code class="language-plaintext highlighter-rouge">uniq</code> when you use <code class="language-plaintext highlighter-rouge">includes</code> because <code class="language-plaintext highlighter-rouge">ActiveRecord</code> will take care of it for you automatically.</p>
  </li>
  <li>Now, what should you do if you want your collection to only have those associations which meet your filter criteria? This situation arose for me when I had to write an API endpoint which let app users pass in parameters to filter associations. There are a couple of ways you can approach this. In my case, since I had to return an object that would eventually be converted to JSON, the simplest way was to manually construct a hash which contained the record and the filtered associations.
 So I did something like this in my controller:</li>
</ol>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">def</span> <span class="nf">show</span> 
   <span class="n">user_attributes</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="ss">projects: </span><span class="n">filtered_projects</span><span class="p">)</span> 
 <span class="k">end</span>
 
 
 <span class="k">def</span> <span class="nf">user_attributes</span> 
   <span class="c1"># returns a hash containing attributes for the given user </span>
   <span class="c1"># something like this: # { id: 1, first_name: 'Rick', last_name: 'Sanchez' } </span>
 <span class="k">end</span>
 
 <span class="k">def</span> <span class="nf">filtered_projects</span> 
   <span class="c1"># here's where I used any Project related params to filter down my projects </span>
   <span class="c1"># something like Project.opened_after(params[:project_date]).as_json </span>
   <span class="c1"># I use as_json because I need this method to return a hash </span>
 <span class="k">end</span>
 <span class="no">Note</span> <span class="n">that</span> <span class="n">the</span> <span class="sb">`merge`</span> <span class="nb">method</span> <span class="n">used</span> <span class="n">here</span> <span class="n">is</span> <span class="n">the</span> <span class="n">one</span> <span class="k">for</span> <span class="sb">`Hash`</span><span class="p">,</span> <span class="n">and</span> <span class="n">not</span> <span class="n">the</span> <span class="sb">`ActiveRecord`</span> <span class="nb">method</span><span class="o">.</span> <span class="no">You</span> <span class="n">should</span> <span class="n">be</span> <span class="n">able</span> <span class="n">to</span> <span class="kp">extend</span> <span class="n">this</span> <span class="n">to</span> <span class="k">return</span> <span class="n">multiple</span> <span class="n">users</span> <span class="n">as</span> <span class="n">well</span><span class="o">.</span>
</code></pre></div></div>
<p>Another way to do this is by defining a scoped <code class="language-plaintext highlighter-rouge">has_many</code> association. If you’re interested in seeing how this might be done, ping me in the comment section below and I’ll do a post on this topic specifically.</p>

<p>Hope this was helpful. As always, if you have a question about this topic that isn’t specifically addressed above, leave a comment below, and I’ll do my best to help out!</p>

      </section>
      <section>
        <!-- Begin Mailchimp Signup Form -->
        <div id="mc-embed-signup">
          <form action="https://ducktypelabs.us10.list-manage.com/subscribe/post?u=f8e882c25616e4d0a58a53fc5&amp;id=e880b701c3" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
              <div id="mc_embed_signup_scroll">
            <h2 class="py-0 my-0 pb-4">Want to be notified when I publish a new article?</h2>
            <div class="form-container">
              <input placeholder="enter email" required type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL">
              <input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button">
            </div>
            <div id="mce-responses">
              <div class="response" id="mce-error-response" style="display:none"></div>
              <div class="response" id="mce-success-response" style="display:none"></div>
            </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
            <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_f8e882c25616e4d0a58a53fc5_e880b701c3" tabindex="-1" value=""></div>
          </form>
        </div>
      </section>
      <footer>© Sid Krishnan</footer>
    </div>
  </body>
</html>
