<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How To Keep Your Controllers Thin with Form Objects</title>
    <link rel="stylesheet" href="/assets/css/style.css">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      <nav>
        <a href="/">About</a>
      </nav>
      <h1>How To Keep Your Controllers Thin with Form Objects</h1>
      <section>
        <p>Typically in Rails, forms which post data to a <code class="language-plaintext highlighter-rouge">#create</code> or <code class="language-plaintext highlighter-rouge">#update</code> action are concerned with one particular resource. For example, a form to update a user’s profile. The sequence looks something like this:</p>

<ol>
  <li>The form submits some data to the <code class="language-plaintext highlighter-rouge">#create</code> action in <code class="language-plaintext highlighter-rouge">UsersController</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">#create</code> action, with something like <code class="language-plaintext highlighter-rouge">User.create(params)</code> creates the record in the <code class="language-plaintext highlighter-rouge">User</code> table.</li>
</ol>

<p>This is easy to reason about. We have one form to create one user. It submits user data to a users controller, which then creates a record in the User table with a call to the <code class="language-plaintext highlighter-rouge">User</code> model.</p>

<p>Though some percentage of the forms in our app can be described this simply, <strong>most forms we find ourselves needing to build are not that simple</strong>. They might need to save multiple records, or update more than one table, and/or perform some additional processing (like sending an email). There might even be more than one context under which a record can be updated (for example a multi-step application form).</p>

<p>Trying to stuff a bunch of logic in your controller can turn out to be quite painful in the long run, as they become longer and harder to understand. Moreover, you might find yourself having to perform gymnastics with your views to get them to pass in parameters correctly.</p>

<p>For example, imagine you’re building a form for a project management app. This form creates a user like in our first example, but in addition, has to do a few other things. First, it has to create a record in the <code class="language-plaintext highlighter-rouge">Message</code> table. Then it has to create a record in the Task table. Finally it has to send an email to the project manager.</p>

<p>Some definitions and assumptions before we go forward:</p>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">Message</code> table is used for internal messaging amongst various members of the project.</li>
  <li>The <code class="language-plaintext highlighter-rouge">Task</code> table is used to store and manage tasks assigned to members of the project.</li>
  <li>When a new user is created, we want to send an internal message and assign a new task to the project manager.</li>
  <li>We also want to send an email notification to the project manager when a new user is created.</li>
</ol>

<p>Compared to the first example, it’s obvious that this form requires a flow that doesn’t quite as neatly fit in to the conventional form flow that we saw earlier. There are a few ways we can handle this:</p>

<ol>
  <li>Add in the code to <code class="language-plaintext highlighter-rouge">UsersController</code> to accomplish the extra stuff.</li>
  <li>If your models are associated with each other (via <code class="language-plaintext highlighter-rouge">has_many</code> or <code class="language-plaintext highlighter-rouge">belongs_to</code>), build a <a href="http://guides.rubyonrails.org/form_helpers.html#nested-forms">nested form</a> using either Rails’ built-in <code class="language-plaintext highlighter-rouge">fields_for</code> helper, or Ryan Bates’ <a href="https://github.com/ryanb/nested_form">nested_form</a> gem. You’ll still have to send the email in the controller.</li>
  <li>Create a new controller and corresponding “form object” that encapsulates what you want to do.</li>
</ol>

<h3 id="what-is-a-form-object">What is a Form Object</h3>

<p>A form object is a Plain Old Ruby Object (PORO). It takes over from the controller wherever it needs to talk to the database and other parts of your app like mailers, service objects and so on. A form object typically functions together with a dedicated controller and a view.</p>

<h3 id="why-use-a-form-object">Why use a Form Object</h3>

<p>Now, while there are good reasons to go with either option 1 or 2, I’m going to elaborate on option 3. There are a few benefits to using a form object in a situation like this:</p>

<ol>
  <li>Your app will be easy to change.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If your app is a decent sized web-app, you will likely have a multitude of paths and views through which data gets saved and/or retrieved from your Users table. It&amp;#8217;s worth thinking about if `UsersController` or the `User` model should be where these paths meet, because if you&amp;#8217;re not careful your controller can devolve into a mess of hard-to-change conditional code.
</code></pre></div></div>

<ol>
  <li>Your app will be easy to reason about</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Conventionally in Rails, the simplest way to reason about a controller is to have it concerned with the seven RESTful actions and views; these actions would only interact with one model and ideally the interaction would be a one-liner like `@user.update(params)`. The closer your controller is to this pattern, the easier your controller will be to reason about.
</code></pre></div></div>

<ol>
  <li>Your view will likely be simpler to write (read: no deeply nested forms) and contain less logic.</li>
</ol>

<h3 id="what-a-form-object-looks-like-in-practice">What a Form Object looks like in practice</h3>

<p><strong>First things first, decide on the name of your new controller.</strong> This will give you quick feedback on if your abstractions will make things easier to reason about.</p>

<p>I always ask myself this, what happens when the form is submitted? In our example above, a user is created and the rest of the project team is notified. So a reasonable name might be ‘UserRegistrationsController`. You can double check by trying to apply the seven RESTful actions to this controller:</p>

<ul>
  <li>Can I “create” a user_registration?</li>
  <li>Can I “update” a user_registration?</li>
  <li>Can I “destroy” a user_registration?</li>
  <li>… and so on</li>
</ul>

<p>All seven actions might not always make sense, which is why I find it handy to define my routes like this, for example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resource :user_registrations, only: [:create, :update, :new, :edit] 
</code></pre></div></div>

<p>In my Rails apps, the convention I follow is to always name the form object class <code class="language-plaintext highlighter-rouge">FormObject</code>, and namespace them with something context dependent. So in this case, my form object would be <code class="language-plaintext highlighter-rouge">UserRegistration::FormObject</code>.</p>

<p>So your form, which resides at <code class="language-plaintext highlighter-rouge">user_registrations/new.html.erb</code>, posts some data to the <code class="language-plaintext highlighter-rouge">#create</code> action of the <code class="language-plaintext highlighter-rouge">UserRegistrationsController</code>, which calls <code class="language-plaintext highlighter-rouge">#save</code> on <code class="language-plaintext highlighter-rouge">UserRegistration::FormObject</code> with the params you pass in.</p>

<h3 id="form-object-parameters">Form Object parameters</h3>

<p>To be able to specify an input in your form, you need to expose the related attribute in your form object. In our example, one of the inputs we want is the user’s name. So in our form object, we’d do:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module UserRegistration
  class FormObject
    include ActiveModel::Model
    attr_accessor :name
    ...
    ...
    def self.model_name
      ActiveModel::Name.new(self, nil, 'UserRegistration')
    end
  end
end
</code></pre></div></div>

<p>Because we’ve said <code class="language-plaintext highlighter-rouge">attr_accessor :name</code>, we can now in our view say something like <code class="language-plaintext highlighter-rouge">&lt;%= f.text_field :name %&gt;</code>.</p>

<p>You’ll also notice a couple of other things:</p>

<ol>
  <li>
    <p>We said <code class="language-plaintext highlighter-rouge">include ActiveModel::Model</code>. This is cool, because we can now use methods like <code class="language-plaintext highlighter-rouge">validates</code> and perform any validations we want. An advantage of using validations in the form object is that they are specific to the form object and won’t clutter up your model(s).</p>
  </li>
  <li>
    <p>We also defined the <code class="language-plaintext highlighter-rouge">model_name</code> class method. The Rails form builder methods (<code class="language-plaintext highlighter-rouge">form_for</code> and the rest) need this to be defined.</p>
  </li>
</ol>

<h3 id="form-object-initialize-and-save">Form Object Initialize and Save</h3>

<p>The behavior of our form object will be governed by two methods. <code class="language-plaintext highlighter-rouge">#initialize</code> and <code class="language-plaintext highlighter-rouge">#save</code>. This is because in our controller, we want to be able define our create action like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def create
  @form_object = UserRegistration::FormObject.new(params)
  if @form_object.save
    ... #typically we flash and redirect here
  else
    render :new
  end
end
</code></pre></div></div>

<p>You can see above how the form object directly replaces the model, allowing us to keep our controller clean and short.</p>

<p>Your initialize method would look something like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def initialize(params)
  self.name = params.fetch(:name, '')
  ... # and so on and so forth
end
</code></pre></div></div>

<p>And save:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
def save
  return false unless valid? #valid? comes from ActiveModel::Model
  User.create(name: name)
  notify_project_manager
  assign_task_to_project_manager
  true
end

private

def notify_project_manager
  ... # here we talk to the Message model
end

def assign_task_to_project_manager
  ... # here we talk to the Task model
end
...
# and so on and so forth
</code></pre></div></div>

<p>The important thing with the <code class="language-plaintext highlighter-rouge">#save</code> method is to return false and true correctly depending on if the form submission meets your criteria, so that your controller can make the right decision.</p>

<h3 id="recap">Recap</h3>

<p>I’m a big fan of form objects, and a general rule of thumb for me is to use them whenever I feel things are getting complicated in the controller and view. They can even be used in situations where you’re not dealing directly with the database (like for example interacting with a third party API).</p>

<p>I encourage you, if you haven’t already, to consider how form objects might fit into your app. They will go a long way in ensuring your controllers <em>and</em> models are thin and keeping your code maintainable.</p>

      </section>
      <section>
        <!-- Begin Mailchimp Signup Form -->
        <div id="mc-embed-signup">
          <form action="https://ducktypelabs.us10.list-manage.com/subscribe/post?u=f8e882c25616e4d0a58a53fc5&amp;id=e880b701c3" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
              <div id="mc_embed_signup_scroll">
            <h2 class="py-0 my-0 pb-4">Want to be notified when I publish a new article?</h2>
            <div class="form-container">
              <input placeholder="enter email" required type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL">
              <input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button">
            </div>
            <div id="mce-responses">
              <div class="response" id="mce-error-response" style="display:none"></div>
              <div class="response" id="mce-success-response" style="display:none"></div>
            </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
            <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_f8e882c25616e4d0a58a53fc5_e880b701c3" tabindex="-1" value=""></div>
          </form>
        </div>
      </section>
      <footer>© Sid Krishnan</footer>
    </div>
  </body>
</html>
