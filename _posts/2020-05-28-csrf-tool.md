---
title: "Do browsers really hide cookies from other domains?"
date: 2020-05-28T10:18:53-04:00
author: Sid
layout: default
permalink: /csrf-tool/
---

[ILLUSTRATION IDEA: gnarly cartoon knot with CSRF, CORS, XSS, CSP, Javascript, Ajax, XHR, cookies, local storage etc]

[ILLUSTRATION IDEA: cat throwing up a gnarly hairball with CSRF, CORS, XSS, CSP, Javascript, Ajax, XHR, cookies, local storage etc]

You're probably aware of the fact that when you make a request from your front-end to your server, the browser can automatically send along any cookies associated to your server's domain with that request. You perhaps also know that you can set CORS headers to bypass the browser's same-origin policy and let your front-end talk to servers which have a different origin from the front-end.

In addition, you might believe that setting a CORS policy ensures that the browser will not automatically send cookies to your server if the request was coming from an origin not specified in the CORS policy. A malicious website open in another browser tab, for instance (aka a CSRF attack). This is, unfortunately, not entirely true.

> "I still am fairly sure that the browser will not send the cookie just because the request is being made to the proper domain. The browser knows the origin the script came from and uses THAT origin to compare with CORS. If I make a website, and the browser is respecting CORS, then there is no way to gain access to cookies from another domain"

Keeping our users safe as they use our apps is, of course, super important. However, because browsers are highly complex, it can be rather easy to develop an incomplete understanding of the browser security model and make reasoning errors that put our users at risk.

As far as a browser is concerned, "requests" are not all created equal. Are you referring to `fetch` or `XMLHTTPRequest`? A regular old form submit with a `POST`, perhaps? Or just a plain URL link that translates to a `GET`? What kind of content type does your server accept? Does the particular endpoint require any data to be sent, and/or does it care about the content-type? The browser behaves slightly differently for each one of these cases, and while correctly setting a CORS policy may protect your users from a subset of them, you can't be sure that your users will be protected against CSRF until you develop a more holistic understanding of the browser security model.

## Browsers are amazing

Browsers are wonderful pieces of software. They give us web app developers a platform to let our imaginations and creativity run wild. Over the years, they have also evolved a multitude of ways to protect our apps' users from harm. This is great, because not only can we build an almost endless variety of apps, we can also rely on the browser to do a substantial amount of work in keeping our users safe.

However, you don't have be an expert in browser software to realize that this duality - being flexible enough to support a large variety of apps _and_ being restrictive enough to protect users from harm - means that browsers often have to tread a fine line between the two concepts. What this implies in practice is that **it falls to us developers to evaluate tradeoffs, _make decisions_ on where to draw the line, and most importantly, figure out if we need to do any _extra_ work to keep our users safe** [reword the bolded statement to be clearer?]

[ILLUSTRATION IDEA: Browser bot on a one line grid-world with fire pits on both sides]

## But do browsers hide cookies from other domains or not?

_It really depends ðŸ˜…_. Take a look at the flowchart below, developed by [Alex Lauerman at Trust Foundry](https://trustfoundry.net/cross-site-request-forgery-cheat-sheet/).

![Trust Foundry CSRF Cheat Sheet](/assets/images/CSRF-CheatSheet-v2.2-3.png)

- The light green "terminal" boxes (where the flowchart ends) indicate scenarios where CSRF is likely. In these scenarios, an attacker can use the user's cookies and thus have "access" to them.
- The pathways leading to the red terminal box (the one which says "CSRF not possible") are worth paying attention to because they tell us how we can prevent CSRF attacks from occuring. In these scenarios, an attacker will not be able to use the user's cookies to carry out an attack.
- A CORS policy, when set, cannot protect your users from CSRF any more than the [same origin policy](https://en.wikipedia.org/wiki/Same-origin_policy) can. In some cases, when set unoptimally, it can potentially increase the likelihood of a CSRF attack.
- The most reliable way to keep CSRF at bay is to use a cryptographically random anti-CSRF token. If you're using an anti-CSRF token, it almost doesn't matter if the browser sends cookies to your server or not, because you'd make your server do a little bit of extra work to verify if the cookies can be trusted.
- Though the flowchart doesn't mention it, correctly setting the `SameSite` flag on your cookies will go a step further to protect your users against CSRF.

<small>Note: This flowchart, and the associated article, was published in 2014, which means some of the information may be out of date by virtue of browsers having evolved newer security measures. I don't think this matters for our purposes though.</small>

CSRF is possible precisely because an attacker is able to use your user's cookies for their benefit, by exploiting edge cases in the intersection of browser behaviour and the specific security configuration choices you've made.

## Is your app vulnerable to CSRF? Use this tool to hack your app and find out! (TODO: put a different background on this tool section?)

Here's a simple tool that I wrote to help you develop a more nuanced understanding of browser security. The aim of it is to teach and get you to question your own notions about how concepts like CORS and CSRF are related.

[NEED AN ILLUSTRATION IDEA: something to do with a robot? feel free to veto]

### How it works (question for Julie: should this section be before or after the "instructions" section)

Once you've entered in an endpoint and a request method, the tool attempts to make the following two requests:

1. Make a [simple request](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests) via the `fetch` API to the specified endpoint, using no extra headers and the default content type.
2. Create a form (within an `iframe` to prevent a redirect) with `action` and `method` set to the specified endpoint and HTTP method(which incidentally is also constrained ), and submit it using the default content type.

The idea is that once the tool does this, you'd head over to your server logs and inspect the result of the requests that were made.

Note that in both cases, the tool doesn't send data to the endpoint. Its only purpose is to see if an authenticated request (matching one of the above two constraints) can be made to your app. Once you verify that this is possible, it should be simple enough to figure out how to send the correct data to it, if needed. The source code for this tool can be found [here](TODO: Add link to code here]. Do experiment with sending data, other content types etc.

### Instructions

- Choose an app that you want to test for CSRF vulnerabilities
- Ensure you have running access to your app server logs. You'll be closely watching logs to verify if the tool is able to make an authenticated request to your app.
- Open the app in another browser tab and log in.
- Once you're back here, open up devtools and go to the Network tab. We'll be keeping an eye on this to see what happens
- Enter in the URL of the endpoint you want to test below (example: `http://localhost:3000/account/12/update`). You want to choose an endpoint that requires that the user be logged in.
- Select the HTTP Method that your endpoint expects.
- Click 'Forge Request!'
- **Now the important bit: Check your server logs.** If you're vulnerable to CSRF, you will either see a successful authenticated request show up in your logs, or an error that tells you authentication was successful but that a failure occurred later in the request cycle (a data validation error for example).
- If you do see an error that indicates a successful authentication, see if you can go further by modifying the request to include additional data.
- Rinse and repeat! Try it on everything you can get your hands on - toy apps, work apps, local environments, deployed environments, your router's admin page etc. Basically, anything that can be opened up in a browser. If you can, also try it on different browsers to investigate if there are any differences in behaviour.

{% include csrf-tool.html %}

### Disclaimer

This tool is a toy, optimized for learning. While it does serve as a decent starting point to verify if you have a CSRF vulnerability, don't trust it blindly.

"Passing" this check doesn't mean you're free from CSRF vulnerabilities. For one, we're restricting ourselves to simple requests. As you saw from the flowchart above, there are potentially ways "complex" requests can be vulnerable to CSRF. Additionally, there are various other things that can go wrong, even if you do everything right (Vulnerabilities in the browser itself, for example. This is rare, but has happened before).

That being said, if you find a bug or an issue with this tool, [write me!](mailto://sidk@ducktypelabs.com)

## Conclusion

Even though browsers sometimes don't protect your cookies from being sent across with requests, it's actually easy to protect your users against CSRF.

While the flowchart we saw earlier looked kind of scary, it turns out that protecting against CSRF is a well known problem that many smart people have thought deeply about. Just two things are needed:

1. An anti-CSRF token should be included with every mutating request. Most frameworks have battle-tested solutions for this.
2. Your cookies should have the `SameSite` flag set to `Strict`(`Lax` at a minimum)

The main benefit of having these defences in place is that it'll let you stop worrying about edge cases in browser behaviour, because you're making your server do the work of verifying if a cookie's origin can be trusted.

If all this makes you think you'd rather avoid the hassle of cookies and put your auth tokens in local storage instead, check out my article that goes through [why sometimes this can be a worse choice]({% post_url 2020-04-29-is-localstorage-bad %}).

Finally, if you found this article useful and would like to be notified when I publish a new one, drop your email in the box below! I aim to publish one twice a month.
